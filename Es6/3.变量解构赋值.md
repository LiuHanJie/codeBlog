# 变量的解构赋值

按照一定模式，以数组或对象形式组织变量进行赋值，这种方法就被称为解构。

## 数组的解构

数组的解构赋值具体规则是数组左边包含的是待声明赋值的变量，数组右边的是变量的值。等号右边的数组的元素，即变量的值的数量可与左边变量的数量不相等，甚至可以是一个空数组。数组的解构赋值中，左边变量数组的索引与右边值的数组的索引一一对应进行赋值。若对应索引位置上没有值，那么变量的值就会是undefined。

```
let [foo = true] = [];
foo // true

let [x, y = 'b'] = ['a']; // x='a', y='b'
let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'

```

此外，结构赋值还能给变量提供默认值，当等号右边值严格等于（就是===全等于）undefined时，默认值才会生效。也就是说使用默认值时不会自动进行类型转换，即便是给变量赋值null也会使得默认值失效。

```
let [x = 1] = [undefined];
x // 1

let [x = 1] = [null];
x // null

```


## 对象的解构赋值

对象的解构赋值不同于数组的解构赋值，数组的解构赋值严格依赖于数组的索引，等号左边的变量数组以及等号右边值的数组根据索引的一一对应进行赋值。而对象的解构赋值则没有这个限制，等号两边只需要有对应的key就可以准确赋值，不需要按照索引或者变量的顺序。

对象的解构赋值中，等号两边的类型必须都要求是对象


```

let { foo, bar } = { bar: 'aaa', foo: 'bbb' };
foo // "aaa"
bar // "bbb"
```

