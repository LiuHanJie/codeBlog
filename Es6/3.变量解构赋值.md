# 变量的解构赋值

按照一定模式，以数组或对象形式组织变量进行赋值，这种方法就被称为解构。

## 数组的解构

数组的解构赋值具体规则是数组左边包含的是待声明赋值的变量，数组右边的是变量的值。等号右边的数组的元素，即变量的值的数量可与左边变量的数量不相等，甚至可以是一个空数组。数组的解构赋值中，左边变量数组的索引与右边值的数组的索引一一对应进行赋值。若对应索引位置上没有值，那么变量的值就会是undefined。

```
let [foo = true] = [];
foo // true

let [x, y = 'b'] = ['a']; // x='a', y='b'
let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'

```

此外，结构赋值还能给变量提供默认值，当等号右边值严格等于（就是===全等于）undefined时，默认值才会生效。也就是说使用默认值时不会自动进行类型转换，即便是给变量赋值null也会使得默认值失效。

```
let [x = 1] = [undefined];
x // 1

let [x = 1] = [null];
x // null

```


## 对象的解构赋值

对象的解构赋值不同于数组的解构赋值，数组的解构赋值严格依赖于数组的索引，等号左边的变量数组以及等号右边值的数组根据索引的一一对应进行赋值。而对象的解构赋值则没有这个限制，等号两边只需要有对应的key就可以准确赋值，不需要按照索引或者变量的顺序。

```

let { foo, bar } = { bar: 'aaa', foo: 'bbb' };
foo // "aaa"
bar // "bbb"
```


对象的解构赋值中，等号两边的类型必须都要求是对象。等号左右两边同名的是匹配模式，不是实际的变量的名，但是默认地匹配模式后面不跟变量名的话变量名就会与匹配模式同名。

```
// 完整的对象解构赋值
let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };

// 等同于
let { foo, bar } = { foo: 'aaa', bar: 'bbb' };

```

实际上接受赋值的变量名可以与等号右边对象的key不相等，如

```
let { foo:f, bar:b } = { bar: 'aaa', foo: 'bbb' };
f // "aaa"
b // "bbb"
```

对已经声明的变量进行解构赋值时需要注意可能导致语法错误。正确的写法应该是使用小括号把整个解构赋值语句包起来。

```
// 错误的写法
let x;
{x} = {x: 1}; 
// SyntaxError: syntax error


// 正确的写法
let x;
({x} = {x: 1});
```


### 字符串、数值、布尔值的解构赋值

字符串、数值、布尔值的解构赋值会先将其转换成对象再进行赋值。undefined和null由于不能转换成对象，所以对undefined和null解构赋值会报错。

### 函数参数的解构赋值

函数参数的解构赋值实际上就是数组或对象解构赋值的一个应用，通过解构赋值给函数设定形参。调用函数传实参的过程中可以直接给函数传数组或对象。


### 解构赋值的用途

1. 交换变量的值
2. 从函数的多个返回值中取出对应的值
3. 函数参数的定义
4. 提取JSON的数据
5. 函数参数设置默认值
6. 遍历map结构
7. 引入模块时指定方法






