# let 和 const 命令

## let命令

let命令用来声明变量，基本功能与var命令几乎一样。不同的地方是let支持块级作用域，以及比var新增了许多在编程习惯中更合理规范的特性。

- 不存在变量提升的问题

    变量提升的简单定义就是：变量的调用可以在声明前发生，而程序也不会报错，变量的值只会是undefined。
    ```
    console.log(foo); // 输出undefined
    var foo = 2;
    ```
    let命令则改变了这一习惯，变量必须在调用前声明，否则程序就会报错
    ```
    console.log(bar); // 报错ReferenceError
    let bar = 2;
    ```

- 暂时性死区

    暂时性死区可以这样理解：只要块级作用域内声明了一个let变量，同时块级外部也有一个同名的变量的情况下，块级内部变量不会受到外部变量的影响。
    
    简而言之就是块级内部只会查找并引用块级内定义的那个变量，而不会到块级外部去调用，即便块级内对变量的调用先于let命令变量的声明。

    ```
    var tmp = 123;

    if (true) {
      tmp = 'abc'; // ReferenceError
      let tmp;
    }

    ```

- 不能重复声明

    同一块级作用域下同一变量名不能重复声明，否则程序就会报错。

    这样会报错：

    ```
    let counter = ()=>{
        var total = 0;
        let total = 100; // ReferenceError
    }

    ```

    这样不会报错：
    ```
    var tmp = 123;

    if (true) {
      let tmp = 456;
      console.log(tmp); // 456
    }

    ```


## 块级作用域

上面的说明中多次提到了”块级作用域“，那么什么是块级作用域呢？有什么用？为什么需要这么一个作用域？

JavaScript以往的版本，也即ES6以前的版本只有全局和函数这两种作用域，而没有块级作用域这个概念。跨级作用域的缺失使得JavaScript这种编程语言欠缺了该有的严谨性和规范性，此外也造成许多编程人员的一些不合理编程习惯。

ES6引入块级作用域实在是一个巨大的进步。

- 为什么需要块级作用域

    1. 没有块级作用域，内层变量会覆盖外层变量
    2. 没有块级作用域，循环中的计算变量泄露成全局变量

- 什么是块级作用域

    以`{}`作为边界的代码块就属于一个块级作用域。代码块内部可以访问父级的变量；同级的代码块内部同名变量不受影响、不被干扰。

- 块级作用域与函数声明

    ECMA规范中明确规定不允许在跨级作用域中声明函数，只能在顶层作用域或函数作用域下声明函数。

    但是，浏览器为了兼容旧代码，即便是声明在块级作用域中的函数也不会导致程序报错。


## const 命令

- const 命令的特性与let基本一致。最大的不同在于const一般用于声明数据常量。const变量保存着数据的指针，一旦被声明赋值就不能再次被赋值，否则就会报错。

- 此外，如果const变量保存的是引用类型的数据，即Array:[]或Object:{},变量仍然不能被再次赋值，但是数组或者对象内部的值是可以被修改的。


## 顶层对象的属性

- 顶层对象在浏览器环境中指的是window，在node环境中指的是global。

- ES5中，顶层对象的属性等同于全局变量。

    ```
    window.a = 1;
    a // 1

    a = 2;
    window.a // 2
    ```
- ES6中开始作出调整，使用let、const、class声明的全局变量不再属于顶层对象的属性

    ```
    var a = 1;
    // 如果在 Node 的 REPL 环境，可以写成 global.a
    // 或者采用通用方法，写成 this.a
    window.a // 1

    let b = 1;
    window.b // undefined
    ```
## globalThis

- 顶层对象的分歧。在不同的js运行环境中，顶层对象的定义并不一致。也就是说当我们获取顶层对象时，在不同运行环境下的顶层对象指向不同的实体。

    1. 浏览器环境中的顶层对象是window
    2. node环境中的顶层对象是global
    3. web worker环境中的顶层对象是self





